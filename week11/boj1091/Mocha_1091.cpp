/*
 *  BOJ 1091. 카드 섞기
 *
 *  시간 복잡도 : O(KN) (K : 1,000,000)
 *  공간 복잡도 : O(N)
 *
 *  매 턴마다 현재 위치가 줘야 하는 플레이어에게 가는 위치인지 확인하고, 모두 맞다면 그 시간을 출력합니다.
 *  그런데 만약 하나라도 맞지 않다면 카드를 섞고 다음에 또 확인을 합니다. 처음엔 작게 돌리다가 안되어서 
 *  적당히 제한 시간내에 돌 수 있게 100만정도로 잡고 돌렸더니 AC가 되네요. 
 *  그렇게 하고 다른 분들 코드를 보니 다른 분들도 100만정도로 잡았네요 ㅋㅋ
 */

#include <algorithm>
#include <cstdio>
using namespace std;

int N, C[50], P[50], S[50], T[50], t, i;

int main(int argc, char *argv[]) {
    scanf("%d", &N);
    for (i = 0; i < N; ++i) scanf("%d", P + i);
    for (i = 0; i < N; ++i) scanf("%d", S + i);

    // t가 섞는 횟수입니다.
    for (t = 0; t <= 1000000; ++t) {
        // 현재 위치가 줘야 하는 플레이어에게 가는 위치인지 확인하다가 안맞으면 멈춥니다.
        for (i = 0; i < N; ++i) if (P[i] != i % 3) break;
        
        // 끝까지 다 맞았으면 된 것이니까 끝냅니다.
        if (i == N) break;

        // 안맞으면 섞습니다.
        for (i = 0; i < N; ++i) T[S[i]] = P[i];
        for (i = 0; i < N; ++i) P[i] = T[i];
    }
    
    // t의 값이 100만을 넘으면 안되는 것이므로 -1을 출력하고 아니라면 그 t값을 출력합니다.
    printf("%d\n", t == 1000001 ? -1 : t);
    return 0;
}