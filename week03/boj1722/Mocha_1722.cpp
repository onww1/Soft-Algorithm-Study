/*
 *  BOJ 1722. 순열의 순서
 * 
 *  팩토리얼을 미리 구해놓고, 그 값을 이용해서 수를 차례차례 구해나가는 식으로 했습니다.
 *  일단 이미 확인된 수를 체크할 visited 배열과 factorial을 저장할 fac 배열을 만들고,
 *  fac 배열에 값을 저장해 주었습니다.
 * 
 *  이후 n과 t를 입력받고, t가 1일 때와 2일 때를 나누어서 처리했습니다.
 * 
 *  우선 1일 때는, 순열을 구하는 것이므로 맨 앞자리부터 차례대로 구한다는 생각으로
 *  반복문의 인덱스를 n부터 시작했습니다. 그렇게 해서 현재 자릿수보다 작은 자릿수의 팩토리얼로
 *  나누었을 때, 0보다 크다면 현재 자릿수가 그만큼 바뀌어야 한다는 것이므로
 *  그 값을 가지고 여태 방문안했던 애들중에 위에서 나누어진 수만큼 뛴 다음 그 다음 방문 안한 수를 출력합니다.
 *  그런 식으로 반복해서 순서대로 구합니다.
 * 
 *  2일 때는, 주어진 순열이 몇 번째 순열인지 알아내는 문제이므로 1과 비슷하게 제일 큰 자릿수부터 해서 
 *  현재 주어진 수보다 작은 수들 중에 아직 나오지 않은 수들을 카운트해서 팩토리얼과 곱해서 더하는 것입니다.
 *  그렇게 하면 그 이전 수에 대한 경우의 수를 한 번에 뛰어 넘을 수 있죠!
 *  그렇게 차례대로 진행하면 수가 나온답니다.
 */

#include <cstdio>
using namespace std;
typedef long long ll;

int main(int argc, char *argv[]) {
  int n, t, i, j; 
  bool visited[21] = {false, };
  ll fac[21] = {1, }, a, s; // 팩토리얼 전처리
  for (i = 1; i <= 20; ++i) fac[i] = fac[i-1] * i;

  scanf("%d %d", &n, &t);
  if (t == 1) { // 순열을 구하는 케이스
    scanf("%lld", &a); --a; // 맨 처음 수가 1번째이므로 그것을 무시하기 위해 1을 빼줌.
    for (i = n; i > 0; --i) {
      if (a / fac[i - 1]) s = a / fac[i - 1], a %= fac[i - 1]; // 이 자릿수에서 몇번 바뀌어야 하는지.
      // 다음 수를 구하는 과정
      if (!s) for (j = 1; visited[j]; ++j); 
      else    for (j = 1; visited[j] || s; ++j) if (!visited[j]) --s;
      // 다음 수를 찾으면 방문 체크하고 출력
      visited[j] = true;
      printf("%d ", j);
    }
  } else {      // 주어진 순열이 몇 번째인지 구하는 케이스
    ll k = 1;   // 맨 처음 수는 1번째이므로 default가 1
    for (i = n; i > 0; --i) {
      scanf("%lld", &a); s = 0;
      for (j = 1; j < a; ++j)   // 주어진 수보다 작은 수들에 대해서 방문 안된 것을 카운트
        if (!visited[j]) ++s;
      visited[a] = true;        // 현재 수를 방문체크하고,
      k += s * fac[i - 1];      // 방문 안된 수들의 갯수와 팩토리얼을 곱해서 k에 더함.
    }
    printf("%lld", k);          // 최종적으로 출력.
  }
  return !printf("\n");
}